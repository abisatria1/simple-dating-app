// Code generated by mockery v2.14.0. DO NOT EDIT.

package user

import (
	context "context"

	entity "github.com/abisatria1/simple-dating-app/src/domain/entity"
	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	model "github.com/abisatria1/simple-dating-app/src/model"
)

// MockUserDomainManager is an autogenerated mock type for the UserDomainManager type
type MockUserDomainManager struct {
	mock.Mock
}

// Begin provides a mock function with given fields: ctx
func (_m *MockUserDomainManager) Begin(ctx context.Context) *gorm.DB {
	ret := _m.Called(ctx)

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func(context.Context) *gorm.DB); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

// BulkInsertUserInterest provides a mock function with given fields: ctx, userInterest, tx
func (_m *MockUserDomainManager) BulkInsertUserInterest(ctx context.Context, userInterest []entity.UserInterest, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, userInterest, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, []entity.UserInterest, *gorm.DB) int64); ok {
		r0 = rf(ctx, userInterest, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []entity.UserInterest, *gorm.DB) error); ok {
		r1 = rf(ctx, userInterest, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateUser provides a mock function with given fields: ctx, user, tx
func (_m *MockUserDomainManager) CreateUser(ctx context.Context, user entity.User, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, user, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, entity.User, *gorm.DB) int64); ok {
		r0 = rf(ctx, user, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, entity.User, *gorm.DB) error); ok {
		r1 = rf(ctx, user, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteLike provides a mock function with given fields: ctx, criteria, tx
func (_m *MockUserDomainManager) DeleteLike(ctx context.Context, criteria entity.UserLike, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, criteria, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, entity.UserLike, *gorm.DB) int64); ok {
		r0 = rf(ctx, criteria, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, entity.UserLike, *gorm.DB) error); ok {
		r1 = rf(ctx, criteria, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIsUserBlacklistedFromCurrentUserFeeds provides a mock function with given fields: ctx, currentUser, targetUser
func (_m *MockUserDomainManager) GetIsUserBlacklistedFromCurrentUserFeeds(ctx context.Context, currentUser int64, targetUser int64) (*entity.UserBlacklist, error) {
	ret := _m.Called(ctx, currentUser, targetUser)

	var r0 *entity.UserBlacklist
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) *entity.UserBlacklist); ok {
		r0 = rf(ctx, currentUser, targetUser)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.UserBlacklist)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, currentUser, targetUser)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMatchUsers provides a mock function with given fields: ctx, userID
func (_m *MockUserDomainManager) GetMatchUsers(ctx context.Context, userID int64) ([]model.UserFeed, error) {
	ret := _m.Called(ctx, userID)

	var r0 []model.UserFeed
	if rf, ok := ret.Get(0).(func(context.Context, int64) []model.UserFeed); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.UserFeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPotentialMatchUsers provides a mock function with given fields: ctx, userID
func (_m *MockUserDomainManager) GetPotentialMatchUsers(ctx context.Context, userID int64) ([]model.UserFeed, error) {
	ret := _m.Called(ctx, userID)

	var r0 []model.UserFeed
	if rf, ok := ret.Get(0).(func(context.Context, int64) []model.UserFeed); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.UserFeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByEmail provides a mock function with given fields: ctx, email
func (_m *MockUserDomainManager) GetUserByEmail(ctx context.Context, email string) (*entity.User, error) {
	ret := _m.Called(ctx, email)

	var r0 *entity.User
	if rf, ok := ret.Get(0).(func(context.Context, string) *entity.User); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserByID provides a mock function with given fields: ctx, ID
func (_m *MockUserDomainManager) GetUserByID(ctx context.Context, ID int64) (*entity.User, error) {
	ret := _m.Called(ctx, ID)

	var r0 *entity.User
	if rf, ok := ret.Get(0).(func(context.Context, int64) *entity.User); ok {
		r0 = rf(ctx, ID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.User)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserFeeds provides a mock function with given fields: ctx, userID
func (_m *MockUserDomainManager) GetUserFeeds(ctx context.Context, userID int64) ([]model.UserFeed, error) {
	ret := _m.Called(ctx, userID)

	var r0 []model.UserFeed
	if rf, ok := ret.Get(0).(func(context.Context, int64) []model.UserFeed); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]model.UserFeed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertBlacklistUser provides a mock function with given fields: ctx, blacklist, tx
func (_m *MockUserDomainManager) InsertBlacklistUser(ctx context.Context, blacklist entity.UserBlacklist, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, blacklist, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, entity.UserBlacklist, *gorm.DB) int64); ok {
		r0 = rf(ctx, blacklist, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, entity.UserBlacklist, *gorm.DB) error); ok {
		r1 = rf(ctx, blacklist, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertLike provides a mock function with given fields: ctx, like, tx
func (_m *MockUserDomainManager) InsertLike(ctx context.Context, like entity.UserLike, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, like, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, entity.UserLike, *gorm.DB) int64); ok {
		r0 = rf(ctx, like, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, entity.UserLike, *gorm.DB) error); ok {
		r1 = rf(ctx, like, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertMatch provides a mock function with given fields: ctx, match, tx
func (_m *MockUserDomainManager) InsertMatch(ctx context.Context, match entity.UserMatch, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, match, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, entity.UserMatch, *gorm.DB) int64); ok {
		r0 = rf(ctx, match, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, entity.UserMatch, *gorm.DB) error); ok {
		r1 = rf(ctx, match, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsLikedBy provides a mock function with given fields: ctx, userID, likeBy
func (_m *MockUserDomainManager) IsLikedBy(ctx context.Context, userID int64, likeBy int64) (*entity.UserLike, error) {
	ret := _m.Called(ctx, userID, likeBy)

	var r0 *entity.UserLike
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) *entity.UserLike); ok {
		r0 = rf(ctx, userID, likeBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*entity.UserLike)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, userID, likeBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateQuota provides a mock function with given fields: ctx, userID, quota, tx
func (_m *MockUserDomainManager) UpdateQuota(ctx context.Context, userID int64, quota int64, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, userID, quota, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64, *gorm.DB) int64); ok {
		r0 = rf(ctx, userID, quota, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, int64, *gorm.DB) error); ok {
		r1 = rf(ctx, userID, quota, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateUser provides a mock function with given fields: ctx, userID, updateField, tx
func (_m *MockUserDomainManager) UpdateUser(ctx context.Context, userID int64, updateField entity.User, tx *gorm.DB) (int64, error) {
	ret := _m.Called(ctx, userID, updateField, tx)

	var r0 int64
	if rf, ok := ret.Get(0).(func(context.Context, int64, entity.User, *gorm.DB) int64); ok {
		r0 = rf(ctx, userID, updateField, tx)
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int64, entity.User, *gorm.DB) error); ok {
		r1 = rf(ctx, userID, updateField, tx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidateUserQuota provides a mock function with given fields: ctx, user
func (_m *MockUserDomainManager) ValidateUserQuota(ctx context.Context, user entity.User) bool {
	ret := _m.Called(ctx, user)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, entity.User) bool); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

type mockConstructorTestingTNewMockUserDomainManager interface {
	mock.TestingT
	Cleanup(func())
}

// NewMockUserDomainManager creates a new instance of MockUserDomainManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMockUserDomainManager(t mockConstructorTestingTNewMockUserDomainManager) *MockUserDomainManager {
	mock := &MockUserDomainManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
